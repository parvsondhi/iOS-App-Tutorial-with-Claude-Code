---
sidebar_position: 2
title: "Chapter 5: Core Feature — Entries"
description: Build the entry creation form, feed display, and edit/delete functionality.
---

import ClaudeCodePrompt from '@site/src/components/ClaudeCodePrompt';
import TwitterCallout from '@site/src/components/TwitterCallout';
import FileTree from '@site/src/components/FileTree';
import TroubleshootingAccordion from '@site/src/components/TroubleshootingAccordion';
import ChapterCheckpoint from '@site/src/components/ChapterCheckpoint';

# Chapter 5: Core Feature — Entries

> The heart of the app. By the end of this chapter, users can create, view, edit, and delete journal entries.

Right now your app has a nice shell but no functionality. Tap "New" and you see a placeholder. That changes now. We're building the full CRUD (Create, Read, Update, Delete) cycle for journal entries — the core of GratitudeJar.

---

## What You'll Build

- An entry creation form with text and photo toggle
- Entry cards that display in a scrollable feed
- Edit mode for updating existing entries
- Delete with confirmation
- Local state management with React hooks (we'll connect Firebase in Chapter 6)

---

## What You'll Learn

- Controlled form inputs in React
- Lifting state up to share data between components
- Conditional rendering for different entry types
- The `Date` API for formatting timestamps
- Array manipulation with `filter`, `map`, and spread syntax

---

## Step 1: Plan the Data Flow

Before writing code, let's think about how data flows through our components:

```
App (owns entries[] state)
├── Header
├── Feed (receives entries, edit/delete handlers)
│   └── EntryCard (renders a single entry)
├── Create (receives addEntry handler)
│   └── EntryForm (form inputs, calls addEntry on submit)
└── BottomNav
```

**Key decisions:**
1. **State lives in `App.tsx`** — the entries array lives at the top and flows down as props
2. **For now, entries live in memory** — refresh the page and they're gone. Chapter 6 adds Firebase persistence.
3. **We'll use the `Entry` type from `types.ts`** — the same data model we designed in Chapter 1

---

## Step 2: Update the Types

Our `Entry` type needs a companion. Since we're working with local state before Firebase, we need a `LocalEntry` type that uses a plain JavaScript `Date` instead of a Firebase `Timestamp` for `createdAt`. This way we can build and test everything without touching the database.

<ClaudeCodePrompt
  variant="build"
  step="Step 2"
  prompt="Update src/lib/types.ts to add a LocalEntry type alongside the existing Entry type. LocalEntry is the same as Entry but uses a plain Date for createdAt instead of a Firebase Timestamp. We'll use LocalEntry for in-memory state before connecting Firebase in the next chapter."
  context="We need two versions of the type — one for Firebase (with Timestamp) and one for local development (with Date). This lets us build the full UI now and swap in the real database later."
  expectedOutput="src/lib/types.ts updated with a new LocalEntry type and a NewEntry type (Entry without id and createdAt, since those are generated automatically)."
/>

Here's what Claude Code generated and why it matters:

- **`LocalEntry`** mirrors the `Entry` type but swaps Firebase's `Timestamp` for a plain `Date`. This means we can create entries in memory without importing anything from Firebase.
- **`NewEntry`** uses `Omit<Entry, 'id' | 'createdAt'>` — this is the shape of an entry *before* it gets saved. No `id` (the database assigns one) and no `createdAt` (the server generates the timestamp). We'll use this in Chapter 6.

---

## Step 3: Create a Helper for Dates

We'll format dates throughout the app, so we need a small utility file. The key insight here is avoiding timezone bugs — a surprisingly common trap.

<ClaudeCodePrompt
  variant="build"
  step="Step 3"
  prompt="Create a date utility file at src/lib/dates.ts with two functions: getLocalDateString() that returns today's date as 'YYYY-MM-DD' using the local timezone (not UTC, to avoid timezone bugs), and formatDisplayDate() that takes a 'YYYY-MM-DD' string and returns a human-friendly format like 'Mar 15, 2025'."
  context="Using toISOString() for dates causes timezone bugs — if it's 11 PM in New York, toISOString() returns tomorrow's date because it converts to UTC. Our helper avoids this by using the local timezone."
  expectedOutput="New file src/lib/dates.ts with getLocalDateString() and formatDisplayDate() functions."
/>

### Why not just use `new Date().toISOString().slice(0, 10)`?

Timezones. If it's 11 PM in New York, `toISOString()` returns the next day's date because it converts to UTC. The `getLocalDateString` function Claude Code generated uses the user's local time, which is what they expect when they log a journal entry.

:::tip Timezone Bugs Are Sneaky
This is one of the most common bugs in apps that deal with dates. A user writes an entry at 11 PM on March 15th, but the app stores it as March 16th. We'll revisit this in Chapter 10 when we build the calendar heatmap.
:::

---

## Step 4: Build the Entry Form

The Create page needs a real form to replace the placeholder. This is the biggest component we've built so far — it handles two different entry types (text and photo), file uploads with previews, and form validation.

<ClaudeCodePrompt
  variant="build"
  step="Step 4"
  prompt="Replace the placeholder src/pages/Create.tsx with a real entry creation form. It needs: a toggle between 'text' and 'photo' entry types (using Type and Image icons from lucide-react), a textarea for text entries, a file input with image preview for photo entries, an optional caption field for photos, and a Save Entry button. The form should create a LocalEntry with crypto.randomUUID() for the id, call an onAddEntry prop with the new entry, then call onClose to navigate back to the feed. Use our amber color scheme with Tailwind."
  context="This is the main creation form for journal entries. It needs to handle both text and photo entries with a clean, mobile-friendly UI."
  expectedOutput="src/pages/Create.tsx rewritten with a full entry creation form including type toggle, content inputs, image preview, and submit handling."
  tip="If the generated form looks different from what you expected, that's fine! The important thing is that it creates a LocalEntry with the right fields and calls onAddEntry."
/>

### Here's what Claude Code built and why it works this way

**Controlled inputs:** Every input's value is tied to state (`content`, `caption`). When the user types, `onChange` updates state, which re-renders the input with the new value. This is the standard React pattern for forms.

**`crypto.randomUUID()`:** Generates a unique ID for each entry. This is a browser API — no library needed. When we switch to Firebase, Firestore will generate IDs instead.

**`URL.createObjectURL(file)`:** Creates a temporary local URL for the selected file so we can preview it. This URL only works in the current browser session — we'll upload to Firebase Storage in Chapter 7 for permanent storage.

**The disabled button:** `disabled={!content.trim()}` prevents submitting an empty entry. The `disabled:opacity-50` Tailwind class visually dims the button.

---

## Step 5: Build the Entry Card

Each entry in the feed needs a card component. This one is interesting because it has multiple modes — normal display, inline editing, and delete confirmation — all managed with local state inside the component.

<ClaudeCodePrompt
  variant="build"
  step="Step 5"
  prompt="Create an EntryCard component at src/components/EntryCard.tsx that displays a single journal entry. It needs: a card header showing the formatted date and edit/delete icon buttons, the entry content (text for text entries, image for photo entries with optional caption), inline edit mode that activates when the pencil icon is clicked, and a delete confirmation bar that slides in at the bottom of the card when the trash icon is clicked. Use Edit3, Trash2, Check, X icons from lucide-react. The component should accept entry, onEdit, and onDelete props."
  context="Each entry card needs to support viewing, inline editing, and delete confirmation — all without navigating away from the feed."
  expectedOutput="New file src/components/EntryCard.tsx with a card component that handles display, inline editing, and delete confirmation."
/>

### Key patterns in what Claude Code generated

**Inline editing:** Instead of navigating to a separate edit page, the card toggles into edit mode directly. This is a common mobile UX pattern — it's faster and keeps the user in context.

**Delete confirmation:** Never delete without confirming. The `showDeleteConfirm` state reveals a red warning bar. This prevents accidental deletions — especially important on mobile where taps can be imprecise.

**`whitespace-pre-wrap`:** This Tailwind class preserves line breaks that the user typed. Without it, a multi-line entry would render as a single paragraph.

**`aria-label`:** Screen readers need text for icon-only buttons. The `aria-label` provides that. Accessibility matters even in tutorials.

---

## Step 6: Update the Feed Page

Now we need to replace the Feed placeholder with a real entry list. The Feed component receives entries as props and renders them using the EntryCard component we just created.

<ClaudeCodePrompt
  variant="build"
  step="Step 6"
  prompt="Update src/pages/Feed.tsx to display a list of entries using the EntryCard component. It should accept entries array, onEdit, and onDelete props. Show an empty state with a message when there are no entries. Render entries in a scrollable list with gap spacing."
  context="The Feed page is the main screen users see. It needs to handle two states: an empty journal (with a helpful message) and a populated journal (with scrollable entry cards)."
  expectedOutput="src/pages/Feed.tsx updated with entry list rendering, empty state, and props for entries and handler functions."
/>

### Here's what Claude Code built and why it works this way

**The empty state:** When there are no entries, the feed shows a helpful message instead of a blank screen. This is the simplest form of an "empty state" — we'll make it much nicer in Chapter 9.

**The `key` prop:** React requires a unique `key` when rendering lists. We use `entry.id` because each entry has a unique identifier. Never use array index as a key — if entries get reordered or deleted, React can't track which is which.

---

## Step 7: Wire Everything Together in App.tsx

Now the big moment — connect all the pieces. App.tsx needs to own the entries state and pass it down to Feed and Create as props, along with handler functions for adding, editing, and deleting.

<ClaudeCodePrompt
  variant="build"
  step="Step 7"
  prompt="Update src/App.tsx to manage entries state with useState. Add handleAddEntry (prepends to array), handleEditEntry (uses map to replace), and handleDeleteEntry (uses filter to remove). Pass entries and handlers as props to Feed and Create. When Create saves an entry, it should auto-navigate back to the Feed tab."
  context="App.tsx is the 'single source of truth' for entries. All data flows down from here as props — this is React's core pattern for state management."
  expectedOutput="src/App.tsx updated with entries useState, three handler functions (add/edit/delete), and props passed to Feed and Create components."
/>

### How state flows

Let's trace what happens when a user creates an entry:

1. User taps the "New" tab -> `setActiveTab('create')` -> Create page renders
2. User types a message and taps "Save Entry"
3. `Create` calls `onAddEntry(newEntry)` -> which is `handleAddEntry` in App
4. `handleAddEntry` calls `setEntries((prev) => [entry, ...prev])` — adds the entry to the front of the array
5. `Create` calls `onClose()` -> which is `setActiveTab('feed')` -> Feed page renders
6. Feed receives the updated `entries` array -> the new entry appears at the top

**The spread operator `[entry, ...prev]`** creates a new array with the new entry first, followed by all previous entries. This gives us newest-first ordering.

**`prev.map(...)` for editing** creates a new array where the matching entry is replaced. The `...entry` spread copies all fields, then `content` and `caption` override the specific fields being edited.

**`prev.filter(...)` for deleting** creates a new array that excludes the entry with the matching id.

<ClaudeCodePrompt
  prompt="I have a React app where entries are stored in useState as an array. I'm using map() for editing and filter() for deleting. Can you explain why I shouldn't mutate the array directly (like using push or splice)?"
  context="Understanding immutable state updates is crucial for React. Mutation bugs are the #1 cause of 'my component won't re-render' issues."
  tip="If React state concepts like immutability feel confusing, ask Claude Code to explain with visual examples."
/>

---

## Step 8: Test the Full CRUD Flow

Start the dev server:

```bash
npm run dev
```

Walk through each operation:

### Create
1. Tap the **New** tab
2. Type "Grateful for sunny weather" in the text area
3. Tap **Save Entry**
4. You should be redirected to Feed, and the entry should appear

### Read
1. The entry card shows the date and your text
2. Create 2-3 more entries — they should stack newest-first

### Update
1. Tap the **pencil icon** on any entry card
2. The text becomes editable
3. Change the text and tap **Save**
4. The card updates with the new content

### Delete
1. Tap the **trash icon** on any entry card
2. A red confirmation bar appears at the bottom of the card
3. Tap **Cancel** — nothing happens
4. Tap **Delete** — the entry disappears

### Photo entries
1. Tap **New**, then select **Photo**
2. Choose an image file from your device
3. Add a caption and save
4. The feed shows the image with the caption below it

---

## Step 9: Commit Your Progress

```bash
git add .
git commit -m "Add CRUD for entries: create form, entry cards, feed display, edit, delete"
git push
```

---

## Understanding What We Built

```
Data Flow:
                    ┌─────────────┐
                    │   App.tsx    │
                    │             │
                    │  entries[]  │ ← single source of truth
                    │             │
                    └──┬───┬──┬──┘
                       │   │  │
            ┌──────────┘   │  └──────────┐
            ▼              ▼             ▼
        ┌──────┐     ┌─────────┐    ┌─────────┐
        │ Feed │     │ Create  │    │ Profile │
        │      │     │         │    │         │
        │ map  │     │ form →  │    │ (later) │
        │  ↓   │     │ addEntry│    │         │
        │Cards │     └─────────┘    └─────────┘
        └──────┘
```

**What's missing?** Persistence. Refresh the page and all entries vanish. That's expected — we're using React state, which only lives in memory. In the next chapter, we connect Firebase Firestore to make entries permanent.

<FileTree title="Updated project structure">

```
gratitude-jar/
├── src/
│   ├── components/
│   │   ├── Header.tsx
│   │   ├── BottomNav.tsx
│   │   └── EntryCard.tsx       ← NEW
│   ├── hooks/
│   ├── lib/
│   │   ├── firebase.ts
│   │   ├── types.ts            ← UPDATED (added LocalEntry)
│   │   └── dates.ts            ← NEW
│   ├── pages/
│   │   ├── Feed.tsx            ← UPDATED (real entry list)
│   │   ├── Create.tsx          ← UPDATED (entry form)
│   │   └── Profile.tsx
│   ├── App.tsx                 ← UPDATED (entries state + CRUD)
│   ├── index.css
│   └── main.tsx
├── .env
├── .gitignore
├── index.html
├── package.json
└── vite.config.ts
```

</FileTree>

<TroubleshootingAccordion items={[
  {
    error: "Entries appear but disappear on page refresh",
    solution: <p>That's expected! Entries are stored in React state (memory) for now. They'll persist after we connect Firebase Firestore in Chapter 6.</p>
  },
  {
    error: "Photo preview doesn't show after selecting a file",
    solution: <p>Make sure you're reading the file with <code>URL.createObjectURL(file)</code>. Check that the <code>onChange</code> handler on the file input is correctly reading <code>e.target.files?.[0]</code>.</p>
  },
  {
    error: "TypeScript error: Property 'caption' is missing",
    solution: <p>Make sure <code>caption</code> is marked as optional with <code>?</code> in both the <code>Entry</code> and <code>LocalEntry</code> types: <code>caption?: string</code>.</p>
  },
  {
    error: "Edit mode doesn't save changes",
    solution: <p>Check that <code>handleEditEntry</code> in App.tsx uses <code>prev.map()</code> to return a new array. The spread <code>{`{...entry, content, caption}`}</code> must come after the spread to override the old values.</p>
  }
]} />

---

## Checkpoint

<ChapterCheckpoint chapter={5}>
- You can **create text entries** and they appear in the Feed
- You can **create photo entries** with an image preview and optional caption
- You can **edit** any entry by tapping the pencil icon
- You can **delete** any entry with a confirmation step
- Entries display in **newest-first order**
- The empty state shows a helpful message when there are no entries
</ChapterCheckpoint>

---

## What's Next

Your app now has real functionality — but the data disappears on refresh. In the next chapter, we connect Firebase Firestore to persist entries in the cloud with real-time syncing.

<TwitterCallout />

**[Next: Chapter 6 — Firebase Backend: Firestore →](./firestore)**
