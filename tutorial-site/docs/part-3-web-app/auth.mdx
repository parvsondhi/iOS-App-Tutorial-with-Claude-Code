---
sidebar_position: 5
title: "Chapter 8: Authentication"
description: Add user authentication with Firebase Auth — login, signup, guest mode, and protected routes.
---

import ClaudeCodePrompt from '@site/src/components/ClaudeCodePrompt';
import TwitterCallout from '@site/src/components/TwitterCallout';
import FileTree from '@site/src/components/FileTree';
import TroubleshootingAccordion from '@site/src/components/TroubleshootingAccordion';
import ChapterCheckpoint from '@site/src/components/ChapterCheckpoint';

# Chapter 8: Authentication

> Right now, anyone can see everyone's entries. Let's add login and make data private.

Authentication is the difference between a toy project and a real app. After this chapter, users will sign up, log in, and only see their own data. We'll use Firebase Authentication with email/password — the simplest auth method that covers all our needs.

---

## What You'll Build

- Login and signup screens with form validation
- A `useAuth()` custom hook for auth state management
- Auth-aware Firestore queries (users only see their own entries)
- Updated security rules for Firestore and Storage
- Logout functionality on the Profile page
- Auth state persistence (stay logged in across sessions)

---

## What You'll Learn

- Firebase Authentication flow (create user, sign in, sign out)
- `onAuthStateChanged` listener — Firebase's auth observer
- How to scope Firestore queries to a user with `where()`
- Security rules that use `request.auth`
- The pattern for protecting routes in a React app

---

## Step 1: Understand the Auth Flow

```
App loads
    ↓
onAuthStateChanged listener fires
    ↓
┌─────── User IS signed in? ──────┐
│                                  │
▼ YES                          ▼ NO
Show app                    Show login screen
(entries filtered             │
 by user ID)            ┌─────┴─────┐
                        │           │
                    Login         Signup
                        │           │
                        └─────┬─────┘
                              ↓
                       Auth succeeds
                              ↓
                    onAuthStateChanged fires
                              ↓
                         Show app
```

**Key principle:** The app doesn't check auth once and move on. `onAuthStateChanged` is a real-time listener — just like `onSnapshot` for Firestore. It fires every time the auth state changes (login, logout, token refresh).

---

## Step 2: Build the `useAuth` Hook

Send this prompt to Claude Code to generate the auth hook, then compare with the reference below:

<ClaudeCodePrompt
  variant="build"
  step="Step 2"
  prompt="Create a custom React hook at src/hooks/useAuth.ts for Firebase authentication. Use onAuthStateChanged as a real-time listener in useEffect (with cleanup). Track user (User | null) and loading state. Expose signup (createUserWithEmailAndPassword), login (signInWithEmailAndPassword), and logout (signOut) functions."
  context="This hook is the foundation of our auth system. It uses Firebase's onAuthStateChanged listener — a real-time observer that fires whenever auth state changes."
  expectedOutput="Claude Code will create src/hooks/useAuth.ts with useState for user/loading, useEffect with onAuthStateChanged, and signup/login/logout functions."
/>

Here's the reference implementation — compare what Claude Code generated with this:

```ts title="src/hooks/useAuth.ts"
import { useState, useEffect } from 'react'
import {
  onAuthStateChanged,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  type User,
} from 'firebase/auth'
import { auth } from '../lib/firebase'

export function useAuth() {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      setUser(user)
      setLoading(false)
    })

    return unsubscribe
  }, [])

  const signup = async (email: string, password: string) => {
    const credential = await createUserWithEmailAndPassword(auth, email, password)
    return credential.user
  }

  const login = async (email: string, password: string) => {
    const credential = await signInWithEmailAndPassword(auth, email, password)
    return credential.user
  }

  const logout = async () => {
    await signOut(auth)
  }

  return {
    user,
    loading,
    signup,
    login,
    logout,
  }
}
```

### Why `loading` starts as `true`

When the app first loads, Firebase needs a moment to check if there's an existing session. During that time, we don't know if the user is logged in or not. The `loading` flag prevents showing the login screen for a split second before the auth state is resolved.

### Firebase handles session persistence automatically

Firebase stores the auth token in `localStorage`. When the user closes the browser and reopens it, `onAuthStateChanged` fires with the stored user — no re-login required. You get session persistence for free.

---

## Step 3: Build the Auth Screen

Send this prompt to Claude Code to generate the auth screen, then compare with the reference below:

<ClaudeCodePrompt
  variant="build"
  step="Step 3"
  prompt="Create a combined login/signup screen at src/pages/AuthScreen.tsx. It should have: email and password inputs with Mail and Lock icons from lucide-react, a toggle between Login and Sign Up modes, form validation (check empty fields, password min 6 chars), error handling that translates Firebase error codes to human-readable messages (auth/user-not-found → 'Invalid email or password', auth/email-already-in-use → 'An account with this email already exists'), and a submitting state with Loader2 spinner. Use the same amber theme. Props: onLogin and onSignup callbacks."
  context="This is the UI component users see when not logged in. It handles both login and signup in one screen with a toggle."
  expectedOutput="Claude Code will create src/pages/AuthScreen.tsx with form state management, Firebase error code translation, and a polished amber-themed login/signup form."
/>

Here's the reference implementation — compare what Claude Code generated with this:

```tsx title="src/pages/AuthScreen.tsx"
import { useState } from 'react'
import { Flower, Mail, Lock, Loader2, AlertCircle } from 'lucide-react'

interface AuthScreenProps {
  onLogin: (email: string, password: string) => Promise<void>
  onSignup: (email: string, password: string) => Promise<void>
}

export default function AuthScreen({ onLogin, onSignup }: AuthScreenProps) {
  const [isLogin, setIsLogin] = useState(true)
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [submitting, setSubmitting] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)

    if (!email.trim() || !password.trim()) {
      setError('Please fill in all fields.')
      return
    }

    if (password.length < 6) {
      setError('Password must be at least 6 characters.')
      return
    }

    setSubmitting(true)

    try {
      if (isLogin) {
        await onLogin(email, password)
      } else {
        await onSignup(email, password)
      }
    } catch (err: any) {
      // Translate Firebase error codes to human-readable messages
      const code = err?.code || ''
      if (code === 'auth/user-not-found' || code === 'auth/wrong-password') {
        setError('Invalid email or password.')
      } else if (code === 'auth/email-already-in-use') {
        setError('An account with this email already exists.')
      } else if (code === 'auth/invalid-email') {
        setError('Please enter a valid email address.')
      } else if (code === 'auth/too-many-requests') {
        setError('Too many attempts. Please try again later.')
      } else {
        setError('Something went wrong. Please try again.')
      }
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <div className="min-h-screen bg-amber-50 flex items-center justify-center px-4">
      <div className="w-full max-w-sm">
        {/* Logo */}
        <div className="text-center mb-8">
          <Flower className="w-12 h-12 text-amber-600 mx-auto mb-3" />
          <h1 className="text-2xl font-bold text-amber-900">GratitudeJar</h1>
          <p className="text-amber-600 mt-1">
            {isLogin ? 'Welcome back' : 'Create your account'}
          </p>
        </div>

        {/* Form */}
        <form onSubmit={handleSubmit} className="flex flex-col gap-4">
          <div className="relative">
            <Mail className="absolute left-3 top-3 w-5 h-5 text-amber-400" />
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Email"
              disabled={submitting}
              className="w-full pl-11 pr-4 py-3 rounded-lg border border-amber-200 bg-white text-amber-900 placeholder-amber-400 focus:outline-none focus:ring-2 focus:ring-amber-500 disabled:opacity-50"
            />
          </div>

          <div className="relative">
            <Lock className="absolute left-3 top-3 w-5 h-5 text-amber-400" />
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Password"
              disabled={submitting}
              className="w-full pl-11 pr-4 py-3 rounded-lg border border-amber-200 bg-white text-amber-900 placeholder-amber-400 focus:outline-none focus:ring-2 focus:ring-amber-500 disabled:opacity-50"
            />
          </div>

          {/* Error message */}
          {error && (
            <div className="flex items-center gap-2 text-red-600 text-sm bg-red-50 p-3 rounded-lg">
              <AlertCircle className="w-4 h-4 flex-shrink-0" />
              {error}
            </div>
          )}

          <button
            type="submit"
            disabled={submitting}
            className="flex items-center justify-center gap-2 py-3 bg-amber-600 text-white rounded-lg font-medium hover:bg-amber-700 transition-colors disabled:opacity-50"
          >
            {submitting ? (
              <Loader2 className="w-5 h-5 animate-spin" />
            ) : (
              isLogin ? 'Log In' : 'Sign Up'
            )}
          </button>
        </form>

        {/* Toggle login/signup */}
        <p className="text-center text-sm text-amber-600 mt-6">
          {isLogin ? "Don't have an account? " : "Already have an account? "}
          <button
            onClick={() => {
              setIsLogin(!isLogin)
              setError(null)
            }}
            className="font-semibold text-amber-700 hover:text-amber-900 underline"
          >
            {isLogin ? 'Sign up' : 'Log in'}
          </button>
        </p>
      </div>
    </div>
  )
}
```

### Error handling matters

Firebase returns error codes like `auth/user-not-found`. Users don't understand those. We translate them into plain English:

| Firebase code | User sees |
|---|---|
| `auth/user-not-found` | "Invalid email or password." |
| `auth/wrong-password` | "Invalid email or password." |
| `auth/email-already-in-use` | "An account with this email already exists." |
| `auth/too-many-requests` | "Too many attempts. Please try again later." |

Notice we use the same message for "user not found" and "wrong password" — this is a security best practice. Telling attackers that an email exists in your system is an information leak.

---

## Step 4: Update the Profile Page

Send this prompt to Claude Code to update the Profile page, then compare with the reference below:

<ClaudeCodePrompt
  variant="build"
  step="Step 4"
  prompt="Update src/pages/Profile.tsx to show the logged-in user's info. Accept user (Firebase User type), onLogout callback, and entryCount as props. Show a circular avatar with UserIcon, the user's email with a Mail icon, an entry count stat card, and a red LogOut button."
  context="Replacing the placeholder Profile page with real user data and a logout button."
  expectedOutput="Claude Code will rewrite src/pages/Profile.tsx with user info display, stats card, and logout functionality."
/>

Here's the reference implementation — compare what Claude Code generated with this:

```tsx title="src/pages/Profile.tsx"
import { User as UserIcon, LogOut, Mail } from 'lucide-react'
import type { User } from 'firebase/auth'

interface ProfileProps {
  user: User
  onLogout: () => Promise<void>
  entryCount: number
}

export default function Profile({ user, onLogout, entryCount }: ProfileProps) {
  return (
    <div className="flex flex-col items-center p-6 gap-6">
      {/* Avatar */}
      <div className="w-20 h-20 rounded-full bg-amber-200 flex items-center justify-center">
        <UserIcon className="w-10 h-10 text-amber-600" />
      </div>

      {/* User info */}
      <div className="text-center">
        <div className="flex items-center gap-2 text-amber-600">
          <Mail className="w-4 h-4" />
          <span className="text-sm">{user.email}</span>
        </div>
      </div>

      {/* Stats */}
      <div className="bg-white rounded-xl border border-amber-200 p-4 w-full max-w-xs text-center">
        <p className="text-3xl font-bold text-amber-900">{entryCount}</p>
        <p className="text-sm text-amber-600">
          {entryCount === 1 ? 'entry' : 'entries'} in your jar
        </p>
      </div>

      {/* Logout */}
      <button
        onClick={onLogout}
        className="flex items-center gap-2 px-6 py-3 text-red-600 bg-red-50 rounded-lg hover:bg-red-100 transition-colors"
      >
        <LogOut className="w-5 h-5" />
        Log Out
      </button>
    </div>
  )
}
```

---

## Step 5: Scope Firestore Queries to the User

Right now, everyone sees everyone's entries. We need to add a `userId` field to entries and filter by it.

Send this prompt to Claude Code to make entries user-specific, then compare with the reference below:

<ClaudeCodePrompt
  variant="build"
  step="Step 5"
  prompt="Make entries user-specific. Update src/lib/types.ts to add a userId field to Entry and exclude it from NewEntry. Update src/lib/firestore.ts: createEntry should accept userId and include it in the document, subscribeToEntries should accept userId and add where('userId', '==', userId) to the query. Update src/hooks/useEntries.ts to accept userId parameter, reset entries when userId is null, and pass userId to createEntry and subscribeToEntries. Add userId to the useEffect dependency array."
  context="This is the critical step that makes data private — each user only sees their own entries."
  expectedOutput="Claude Code will update types.ts, firestore.ts, and useEntries.ts to scope all data operations to the authenticated user's ID."
/>

### Update the types

```ts title="src/lib/types.ts"
import { Timestamp } from 'firebase/firestore'

export type Entry = {
  id: string
  userId: string          // NEW — the Firebase Auth UID
  type: 'text' | 'photo'
  content: string
  caption?: string
  date: string
  createdAt: Timestamp
}

export type NewEntry = Omit<Entry, 'id' | 'createdAt' | 'userId'>
```

### Update the Firestore service

```ts title="src/lib/firestore.ts"
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  query,
  where,
  orderBy,
  onSnapshot,
  serverTimestamp,
} from 'firebase/firestore'
import { db } from './firebase'
import type { Entry, NewEntry } from './types'

const ENTRIES_COLLECTION = 'entries'

export async function createEntry(entry: NewEntry, userId: string): Promise<string> {
  const docRef = await addDoc(collection(db, ENTRIES_COLLECTION), {
    ...entry,
    userId,
    createdAt: serverTimestamp(),
  })
  return docRef.id
}

export async function updateEntry(
  id: string,
  updates: Partial<Pick<Entry, 'content' | 'caption'>>
): Promise<void> {
  const docRef = doc(db, ENTRIES_COLLECTION, id)
  await updateDoc(docRef, updates)
}

export async function deleteEntry(id: string): Promise<void> {
  const docRef = doc(db, ENTRIES_COLLECTION, id)
  await deleteDoc(docRef)
}

export function subscribeToEntries(
  userId: string,
  callback: (entries: Entry[]) => void,
  onError: (error: Error) => void
): () => void {
  const q = query(
    collection(db, ENTRIES_COLLECTION),
    where('userId', '==', userId),
    orderBy('createdAt', 'desc')
  )

  const unsubscribe = onSnapshot(
    q,
    (snapshot) => {
      const entries: Entry[] = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Entry[]
      callback(entries)
    },
    onError
  )

  return unsubscribe
}
```

The critical change: `where('userId', '==', userId)` in the query. This means each user only receives documents that belong to them.

### Update the `useEntries` hook

```ts title="src/hooks/useEntries.ts"
import { useState, useEffect } from 'react'
import {
  subscribeToEntries,
  createEntry,
  updateEntry,
  deleteEntry,
} from '../lib/firestore'
import type { Entry, NewEntry } from '../lib/types'

export function useEntries(userId: string | null) {
  const [entries, setEntries] = useState<Entry[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!userId) {
      setEntries([])
      setLoading(false)
      return
    }

    setLoading(true)
    const unsubscribe = subscribeToEntries(
      userId,
      (updatedEntries) => {
        setEntries(updatedEntries)
        setLoading(false)
      },
      (err) => {
        console.error('Firestore subscription error:', err)
        setError('Failed to load entries. Check your internet connection.')
        setLoading(false)
      }
    )

    return unsubscribe
  }, [userId])

  const addEntry = async (entry: NewEntry) => {
    if (!userId) return
    try {
      await createEntry(entry, userId)
    } catch (err) {
      console.error('Failed to create entry:', err)
      setError('Failed to save entry. Please try again.')
    }
  }

  const editEntry = async (id: string, content: string, caption?: string) => {
    try {
      await updateEntry(id, { content, caption })
    } catch (err) {
      console.error('Failed to update entry:', err)
      setError('Failed to update entry. Please try again.')
    }
  }

  const removeEntry = async (id: string) => {
    try {
      await deleteEntry(id)
    } catch (err) {
      console.error('Failed to delete entry:', err)
      setError('Failed to delete entry. Please try again.')
    }
  }

  return {
    entries,
    loading,
    error,
    addEntry,
    editEntry,
    removeEntry,
  }
}
```

Notice the `[userId]` dependency in `useEffect`. When the user logs in or switches accounts, the subscription refreshes with the new userId.

---

## Step 6: Wire Auth into App.tsx

Send this prompt to Claude Code to integrate authentication into the app, then compare with the reference below:

<ClaudeCodePrompt
  variant="build"
  step="Step 6"
  prompt="Update src/App.tsx to integrate authentication. Use useAuth() hook alongside useEntries(user?.uid ?? null). Add three render states: 1) if authLoading, show a full-screen spinner, 2) if no user, show AuthScreen with login/signup callbacks, 3) if user exists, show the full app. Pass the user object to Profile along with logout and entryCount."
  context="This wires together the auth hook, entries hook, and UI components into the auth gate pattern."
  expectedOutput="Claude Code will update App.tsx with useAuth integration, three conditional render states, and proper prop passing to AuthScreen and Profile."
/>

Here's the reference implementation — compare what Claude Code generated with this:

```tsx title="src/App.tsx"
import { useState } from 'react'
import Header from './components/Header'
import BottomNav from './components/BottomNav'
import Feed from './pages/Feed'
import Create from './pages/Create'
import Profile from './pages/Profile'
import AuthScreen from './pages/AuthScreen'
import { useAuth } from './hooks/useAuth'
import { useEntries } from './hooks/useEntries'
import { Loader2 } from 'lucide-react'

type Tab = 'feed' | 'create' | 'profile'

function App() {
  const [activeTab, setActiveTab] = useState<Tab>('feed')
  const { user, loading: authLoading, signup, login, logout } = useAuth()
  const { entries, loading: entriesLoading, error, addEntry, editEntry, removeEntry } = useEntries(user?.uid ?? null)

  // Show loading while checking auth state
  if (authLoading) {
    return (
      <div className="min-h-screen bg-amber-50 flex items-center justify-center">
        <Loader2 className="w-8 h-8 text-amber-500 animate-spin" />
      </div>
    )
  }

  // Show auth screen if not logged in
  if (!user) {
    return (
      <AuthScreen
        onLogin={async (email, password) => { await login(email, password) }}
        onSignup={async (email, password) => { await signup(email, password) }}
      />
    )
  }

  // User is logged in — show the app
  return (
    <div className="min-h-screen bg-amber-50">
      <Header />

      <main className="max-w-lg mx-auto pt-14 pb-20 min-h-screen">
        <div className="h-[calc(100vh-8.5rem)] flex flex-col">
          {activeTab === 'feed' && (
            <Feed
              entries={entries}
              loading={entriesLoading}
              error={error}
              onEdit={editEntry}
              onDelete={removeEntry}
            />
          )}
          {activeTab === 'create' && (
            <Create
              onAddEntry={addEntry}
              onClose={() => setActiveTab('feed')}
            />
          )}
          {activeTab === 'profile' && (
            <Profile
              user={user}
              onLogout={logout}
              entryCount={entries.length}
            />
          )}
        </div>
      </main>

      <BottomNav activeTab={activeTab} onTabChange={setActiveTab} />
    </div>
  )
}

export default App
```

### The auth gate pattern

The app has three states:

1. **Loading** — checking auth → show a spinner
2. **Not authenticated** — no user → show `AuthScreen`
3. **Authenticated** — user exists → show the full app

This is the simplest form of "route protection." No router library needed.

<ClaudeCodePrompt
  prompt="I'm using Firebase Auth's onAuthStateChanged to gate my React app — if no user, show login; if user, show app. Is there a better pattern? Should I use React Router with protected routes instead?"
  context="For a simple tab-based app, the conditional rendering pattern in App.tsx is fine. React Router adds value when you have URLs to manage."
/>

---

## Step 7: Update Security Rules

Now that we have authentication, let's lock down Firestore and Storage:

### Firestore rules

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /entries/{entryId} {
      // Users can only read their own entries
      allow read: if request.auth != null
                  && resource.data.userId == request.auth.uid;

      // Users can only create entries for themselves
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid;

      // Users can only update/delete their own entries
      allow update, delete: if request.auth != null
                            && resource.data.userId == request.auth.uid;
    }
  }
}
```

### Storage rules

```
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    match /entries/{filename} {
      // Anyone signed in can read photos (needed for feed)
      allow read: if request.auth != null;

      // Anyone signed in can upload (max 10MB)
      allow write: if request.auth != null
                   && request.resource.size < 10 * 1024 * 1024;
    }
  }
}
```

### What these rules enforce

- **No anonymous access** — every request must have `request.auth != null`
- **Data isolation** — users can only read/write their own entries (`userId == request.auth.uid`)
- **File size limits** — uploads are capped at 10MB
- Even if someone manually sends a Firestore request with another user's ID, the security rules will block it

:::warning Firestore Composite Index
When you combine `where()` and `orderBy()` on different fields, Firestore may require a composite index. If you see an error in the console with a link to create the index, click the link — Firebase will create it automatically. This is a one-time setup.
:::

---

## Step 8: Test Authentication

```bash
npm run dev
```

1. **Open the app** — you should see the login screen (not the app)
2. **Click "Sign up"** — create an account with an email and password
3. **After signup** — you should be redirected to the app automatically
4. **Create some entries** — they should work as before
5. **Open the Firebase console** → Authentication — you should see your user
6. **Check Firestore** — entries should now have a `userId` field
7. **Refresh the page** — you should still be logged in (session persistence)
8. **Log out** (Profile → Log Out) — back to the login screen
9. **Log in again** — your entries should still be there

### Test data isolation

1. Create Account A with some entries
2. Log out
3. Create Account B
4. Account B should see an empty feed — Account A's entries are private

---

## Step 9: Commit Your Progress

```bash
git add .
git commit -m "Add authentication: login, signup, user-scoped entries, security rules"
git push
```

---

<FileTree title="Updated project structure">

```
gratitude-jar/
├── src/
│   ├── components/
│   │   ├── Header.tsx
│   │   ├── BottomNav.tsx
│   │   └── EntryCard.tsx
│   ├── hooks/
│   │   ├── useAuth.ts         ← NEW
│   │   └── useEntries.ts      ← UPDATED (userId param)
│   ├── lib/
│   │   ├── firebase.ts
│   │   ├── firestore.ts       ← UPDATED (userId in queries)
│   │   ├── storage.ts
│   │   ├── image.ts
│   │   ├── types.ts            ← UPDATED (added userId)
│   │   └── dates.ts
│   ├── pages/
│   │   ├── AuthScreen.tsx      ← NEW
│   │   ├── Feed.tsx
│   │   ├── Create.tsx
│   │   └── Profile.tsx         ← UPDATED (user info + logout)
│   ├── App.tsx                 ← UPDATED (auth gate)
│   ├── index.css
│   └── main.tsx
└── ...
```

</FileTree>

<TroubleshootingAccordion items={[
  {
    error: "FirebaseError: The query requires an index",
    solution: <p>Firestore needs a composite index for queries that combine <code>where()</code> and <code>orderBy()</code> on different fields. The error message includes a direct link — click it to create the index in the Firebase console. It takes about a minute to build.</p>
  },
  {
    error: "Login works but entries don't appear (empty feed)",
    solution: <p>Your existing entries from before Chapter 8 don't have a <code>userId</code> field. The <code>where('userId', '==', userId)</code> filter won't match them. Delete the old entries from the Firebase console and create new ones while logged in.</p>
  },
  {
    error: "auth/invalid-api-key error",
    solution: <p>Your <code>VITE_FIREBASE_API_KEY</code> in the <code>.env</code> file is wrong. Copy it again from the Firebase console → Project settings → Your apps → Web app → Config.</p>
  },
  {
    error: "Signup works but login fails with 'user not found'",
    solution: <p>Make sure you're using the same email for both. Firebase Auth is case-sensitive for emails in some configurations. Also check that Email/Password is enabled in Firebase Console → Authentication → Sign-in method.</p>
  }
]} />

---

## Checkpoint

<ChapterCheckpoint chapter={8}>
- The app shows a **login screen** when not authenticated
- Users can **sign up** with email and password
- Users can **log in** to an existing account
- Entries are **scoped to the logged-in user** — each user sees only their data
- **Refreshing the page** keeps the user logged in
- **Logging out** returns to the login screen
- The Profile page shows the **user's email** and **entry count**
- Firestore security rules **block unauthorized access**
</ChapterCheckpoint>

---

## What's Next

Your app is functional and secure. But it's missing the small touches that make an app feel polished — empty states, loading skeletons, error handling, and an onboarding experience. That's Chapter 9.

<TwitterCallout />

**[Next: Chapter 9 — Polish: States & Onboarding →](./polish)**
